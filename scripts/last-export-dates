#!/usr/bin/env python3

"""
For exports which I have to do manually --
i.e. go to some website, login, request and then
download, this reminds me to do it when my newest
local data is over 90 days old
"""

from __future__ import annotations
from time import time
from pathlib import Path
from functools import cached_property
from typing import (
    cast,
    Any,
    Iterator,
    List,
    Callable,
    NamedTuple,
    Iterable,
)
from dataclasses import dataclass
from datetime import datetime, timedelta

import click
import my.google.takeout.parser
import my.discord.data_export
from my import smscalls
from my.activitywatch import active_window
from my.core import get_files
from my.scramble.history import parsed_conf
from my.core.query import attribute_func
from my.core.query_range import select_range
from tabulate import tabulate
from seanb.notify import notify


class FileResult(NamedTuple):
    """
    When a file was created/last modified as the export time
    """

    path: Path
    mtime: datetime

    @classmethod
    def from_paths(cls, paths: Iterable[Path]) -> Iterator[FileResult]:
        for p in sorted(list(paths)):
            yield cls(p, datetime.fromtimestamp(p.stat().st_mtime))


def _notify_over_days(name: str, over_days: int) -> None:
    msg = f"{name} exported over {over_days} days ago"
    click.echo(msg)
    notify(
        msg,
        title="last-export-dates",
    )


AttrFunc = Callable[[Any], datetime]


@dataclass
class Export:
    name: str
    func: Callable[[], Iterator[Any]] | Iterator[Any]
    over_days: int = 28  # if data is older than this, notify

    @property
    def wfunc(self) -> Callable[[], Iterator[Any]]:
        if callable(self.func):
            return self.func
        else:
            assert isinstance(
                self.func, Iterator
            ), f"func must be callable or iterator {self.func}"

            def _func() -> Iterator[Any]:
                for o in self.func:
                    yield o

            return _func

    @cached_property
    def days_since_export(self) -> float:
        # function which when given an item returns the datetime
        attrfunc: AttrFunc = cast(
            AttrFunc,
            attribute_func(
                next(filter(lambda o: o is not None, self.wfunc())),
                where=lambda o: isinstance(o, datetime),
            ),
        )
        assert callable(attrfunc), f"attrfunc must be callable {attrfunc}"

        # sort function results by datetime, drop anything that cant be sorted
        itr = select_range(
            self.wfunc(), order_by_value_type=datetime, drop_unsorted=True
        )

        # filter out any none values
        some = filter(lambda o: attrfunc(o) is not None, itr)
        # attrfunc(o) will return the datetime, get the most recent
        most_recent_dt: datetime = attrfunc(max(some, key=attrfunc))
        # calculate diff with the most recent datetime with now
        return (time() - most_recent_dt.timestamp()) / timedelta(days=1).total_seconds()

    def time_description(self, days_since: float) -> str:
        return f"{str(round(days_since, 2)).ljust(5)} / {self.over_days}"

    def process(self, override_days: int | None) -> List[str]:
        over_days = override_days or self.over_days
        if self.days_since_export > over_days:
            _notify_over_days(self.name, over_days)
        return [self.name, self.time_description(self.days_since_export)]


EXPORTS: List[Export] = [
    Export("TwistyTimer", FileResult.from_paths(parsed_conf["twistytimer"])),
    Export(
        "ActivityWatch Phone",
        active_window.history(
            from_paths=lambda: [
                p for p in active_window.inputs() if "aw-window/phone" in str(p)
            ]
        ),
    ),
    Export(
        "SMS Export",
        FileResult.from_paths(get_files(smscalls.config.export_path, glob="sms-*.xml")),
        over_days=14,
    ),
    Export("Discord Data Export", my.discord.data_export.messages, over_days=150),
    Export("Google Takeout", my.google.takeout.parser.events, over_days=90),
]


@click.command(help=__doc__, context_settings={"max_content_width": 100})
@click.option(
    "-n",
    "--override-days",
    "_override",
    type=int,
    default=None,
    help="If over this many days, notify/warn",
)
def main(_override: int | None) -> None:
    """
    Warn me to do exports I do manually, periodicaly
    """
    click.echo(
        tabulate(
            list(map(lambda exp: exp.process(_override), EXPORTS)),
            headers=(
                "Export",
                "Days Since",
            ),
        )
    )


if __name__ == "__main__":
    main()
