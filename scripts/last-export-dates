#!/usr/bin/env python3

"""
For exports which I have to do manually --
i.e. go to some website, login, request and then
download, this reminds me to do it when my newest
local data is over 90 days old
"""

from __future__ import annotations
from time import time
from pathlib import Path
from functools import cached_property
from typing import (
    cast,
    Any,
    Iterator,
    List,
    TYPE_CHECKING,
    Callable,
    NamedTuple,
    Iterable,
)
from dataclasses import dataclass
from datetime import datetime, timedelta

import click
import my.google.takeout.parser
import my.discord.data_export
from my.core.query import attribute_func
from my.core.query_range import select_range
from tabulate import tabulate
from seanb.notify import notify


if TYPE_CHECKING:
    from my.activitywatch.active_window import Result


def _aw_window_watcher() -> Iterator[Result]:
    from my.activitywatch.active_window import inputs, history

    use: Callable[[], List[Path]] = lambda: [
        p for p in inputs() if "aw-window/phone" in str(p)
    ]
    yield from history(from_paths=use)


class FileResult(NamedTuple):
    """
    When a file was created/last modified as the export time
    """

    path: Path
    mtime: datetime

    @classmethod
    def from_paths(cls, paths: Iterable[Path]) -> Iterator[FileResult]:
        for p in sorted(list(paths)):
            yield cls(p, datetime.fromtimestamp(p.stat().st_mtime))


def _twistytimer() -> Iterator[FileResult]:
    from my.scramble.history import parsed_conf

    yield from FileResult.from_paths(parsed_conf["twistytimer"])


def _last_sms_export() -> Iterator[FileResult]:
    from my.smscalls import config, get_files

    yield from FileResult.from_paths(get_files(config.export_path, glob="sms-*.xml"))


DAY = timedelta(days=1).total_seconds()


def _notify_over_days(name: str, over_days: int) -> None:
    msg = f"{name} exported over {over_days} days ago"
    click.echo(msg)
    notify(
        msg,
        title="last-export-dates",
    )


AttrFunc = Callable[[Any], datetime]


@dataclass
class Export:
    name: str
    func: Callable[[], Iterator[Any]]
    over_days: int = 28  # if data is older than this, notify

    @cached_property
    def days_since_export(self) -> float:
        # function which when given an item returns the datetime
        attrfunc: AttrFunc = cast(
            AttrFunc,
            attribute_func(
                next(filter(lambda o: o is not None, self.func())),
                where=lambda o: isinstance(o, datetime),
            ),
        )
        assert callable(attrfunc), f"attrfunc must be callable {attrfunc}"

        # sort function results by datetime, drop anything that cant be sorted
        itr = select_range(
            self.func(), order_by_value_type=datetime, drop_unsorted=True
        )

        # filter out any none values
        some = filter(lambda o: attrfunc(o) is not None, itr)
        # attrfunc(o) will return the datetime, get the most recent
        most_recent_dt: datetime = attrfunc(max(some, key=attrfunc))
        # calculate diff with the most recent datetime with now
        return (time() - most_recent_dt.timestamp()) / DAY

    def time_description(self, days_since: float) -> str:
        return f"{str(round(days_since, 2)).ljust(5)} / {self.over_days}"

    def process(self, override_days: int | None) -> List[str]:
        over_days = override_days or self.over_days
        if self.days_since_export > over_days:
            _notify_over_days(self.name, over_days)
        return [self.name, self.time_description(self.days_since_export)]


EXPORTS: List[Export] = [
    Export("TwistyTimer", _twistytimer),
    Export("ActivityWatch Phone", _aw_window_watcher),
    Export("SMS Export", _last_sms_export, over_days=14),
    Export("Discord Data Export", my.discord.data_export.messages, over_days=150),
    Export("Google Takeout", my.google.takeout.parser.events, over_days=90),
]


@click.command(help=__doc__, context_settings={"max_content_width": 100})
@click.option(
    "-n",
    "--override-days",
    "_override",
    type=int,
    default=None,
    help="If over this many days, notify/warn",
)
def main(_override: int | None) -> None:
    """
    Warn me to do exports I do manually, periodicaly
    """
    click.echo(
        tabulate(
            list(map(lambda exp: exp.process(_override), EXPORTS)),
            headers=(
                "Export",
                "Days Since",
            ),
        )
    )


if __name__ == "__main__":
    main()
