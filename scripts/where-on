#!/usr/bin/env python3

"""
figure out where I was on a date

saves to a database once a day to update
accepts any sort of date-like string and queries the db
"""

import os
import sys
import json
from collections import defaultdict
from pathlib import Path
from typing import Sequence, Iterator, Optional, List, Tuple, Mapping
from functools import cache
from datetime import datetime, date, timedelta

import click

from my.location.common import Location, LatLon


Model = Tuple[float, float, int]
ModelDt = Tuple[float, float, datetime]


def _serialize(loc: Location) -> ModelDt:
    return (loc.lat, loc.lon, loc.dt)


def generate_from_locations(
    *, accuracy_filter: int, distance_filter: int
) -> Iterator[Tuple[float, float, datetime]]:
    import geopy.distance
    from my.location.all import locations

    locs: List[Location] = [
        loc
        for loc in locations()
        if loc.accuracy is not None and loc.accuracy < accuracy_filter
    ]
    locs.sort(key=lambda l: l.dt)
    last = locs[0]
    yield _serialize(last)
    for cur in locs[1:]:
        last_latlon: LatLon = (last.lat, last.lon)
        cur_latlon: LatLon = (cur.lat, cur.lon)
        dist = geopy.distance.distance(last_latlon, cur_latlon)
        # if we've hit distance filter threshold, or we haven't
        # sent a location in the last 3 hours, send a new one
        if dist.m > distance_filter or cur.dt - last.dt > timedelta(hours=3):
            yield _serialize(cur)
            last = cur


@cache
def _homes(reverse: bool = False) -> List[Tuple[datetime, LatLon]]:
    """cached home data"""
    from my.location.home import config

    hist: List[Tuple[datetime, LatLon]] = list(config._history)
    hist.sort(key=lambda data: data[0], reverse=reverse)
    return hist


def _home(on_dt: datetime) -> ModelDt:
    """
    given a datetime, give the location/date of my home at the time
    """
    ndt = _naive(on_dt)
    for dt, (lat, lon) in _homes(reverse=True):
        if ndt >= _naive(dt):
            click.echo(f"matched {dt} {lat} {lon} for {on_dt}")
            return (lat, lon, _naive(dt))

    # default to last home
    last = _homes()[-1]
    ldt, (llon, llat) = last
    return (llat, llon, _naive(ldt))


def _naive(dt: datetime) -> datetime:
    """remove timezone from a datetime"""
    return datetime.fromtimestamp(dt.timestamp())


def generate(*, accuracy_filter: int, distance_filter: int) -> Iterator[Model]:
    # relate each item to a day, and add that to a list
    # if none present on that day, default to my home location
    loc_on_day: Mapping[date, List[ModelDt]] = defaultdict(list)
    for loc in generate_from_locations(
        distance_filter=distance_filter, accuracy_filter=accuracy_filter
    ):
        _, _, dt = loc
        loc_on_day[dt.date()].append(loc)

    # start at the first date available + 1 day to account for weird timezone stuff
    cur: datetime = _naive(_homes()[0][0]) + timedelta(days=1)

    # or, if we actually have location data that far back, use locations
    first_key = list(sorted(loc_on_day.keys()))[0]
    if first_key < cur.date():
        cur = loc_on_day[first_key][0][2]
        assert isinstance(cur, datetime)

    # if we've had some accurate locations, use
    # those for a week instead of home
    last_accurate: Optional[ModelDt] = None

    # sometime after Im confident
    # Ive been logging stuff with gpslogger very
    # frequently
    #
    # TODO: make confirurable
    cutoff = date(2020, 10, 15)

    # TODO: make last_accurate usage time (7 days) configurable

    # loop through a day at a time, either using home
    # or using the dates generated from locations
    while cur <= datetime.now():
        # if we dont have accurate up to date locations
        if cur.date() not in loc_on_day:
            # continue using last accurate timestamp/location till we have a new one
            # or its been 7 days since the last accurate one
            if last_accurate is not None and (
                cur.date() > cutoff or abs((cur - _naive(last_accurate[2])).days) < 7
            ):
                yield (last_accurate[0], last_accurate[1], int(cur.timestamp()))
            else:
                # else, fallback to use home location
                lat, lon, _ = _home(cur)
                yield (lat, lon, int(cur.timestamp()))
        else:
            # we have accurate locations, use those
            for aloc in loc_on_day[cur.date()]:
                yield (aloc[0], aloc[1], int(aloc[2].timestamp()))
                last_accurate = aloc
        cur += timedelta(days=1)


@click.group()
def main():
    """
    figure out where I was on a date
    """


@main.command(short_help="generate database")
@click.option(
    "--distance-filter",
    type=int,
    default=100,
    help="distance (in metres) to require to create a new data point",
)
@click.option(
    "--accuracy-filter",
    type=int,
    default=300,
    help="accuracy required for location data",
)
@click.argument("OUTPUT", type=click.Path(path_type=Path), required=False)
def gen(output: Optional[str], distance_filter: int, accuracy_filter: int) -> None:
    """
    generates the database which stores where I was at particular times

    the distance filter removes duplicate points
    which return data within some range,
    defaults to 100m
    """
    res = list(
        generate(distance_filter=distance_filter, accuracy_filter=accuracy_filter)
    )
    if output is None:
        click.echo(json.dumps(res))
    else:
        Path(output).write_text(json.dumps(res))


def _load_db(db_file: Path) -> List[Model]:
    with open(db_file, "r") as f:
        data = json.load(f)
        assert isinstance(data, list)
        return data


def run_query(timestamp: int, db: List[Model]) -> Tuple[float, float]:
    for (lat, lon, ts) in db:
        if ts > timestamp:
            return lat, lon
    else:
        raise RuntimeError("Could not find matching location")


def _parse_datetimes(dates: Sequence[str]) -> Iterator[int]:
    import dateparser

    for d in dates:
        dt = dateparser.parse(d)
        if dt is None:
            click.echo(f"Could not parse {d} into a date", err=True)
            sys.exit(1)
        else:
            yield int(dt.timestamp())


def default_db() -> Optional[Path]:
    defaults: List[Path] = []
    if "HPIDATA" in os.environ:
        defaults.append(Path(os.environ["HPIDATA"]))
    defaults.extend([Path("~/.local/share/"), Path("~/.cache/")])
    for d in defaults:
        dd = d.expanduser() / "where-on.json"
        if dd.exists():
            return dd
    return None


@main.command(short_help="query database")
@click.option(
    "--db",
    help="read from database",
    type=click.Path(exists=True, path_type=Path),
    required=True,
    default=default_db(),
)
@click.option("--url/--no-url", is_flag=True, help="print google location URL")
@click.argument("DATE", type=str, required=True, nargs=-1)
def query(db: Path, url: bool, date: Sequence[str]) -> None:
    dts = list(_parse_datetimes(date))
    data = _load_db(db)
    for d in dts:
        lat, lon = run_query(d, db=data)
        if url:
            click.echo(f"https://www.google.com/search?q={lat}%2C{lon}")
        else:
            click.echo(f"{lat},{lon}")


if __name__ == "__main__":
    main()
